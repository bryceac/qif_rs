=QIF=

<dl>
<dt style="font-weight:bold">Version</dt>
<dd>0.1</dd>
<dt style="font-weight:bold">Author</dt>
<dd>Bryce Campbell</dd>
<dt style="font-weight:bold">License</dt>
<dd>see LICENSE</dd>
<dt style="font-weight:bold">Description</dt>
<dd>
<p>A rust port of 
<a href="https://github.com/bryceac/QIF">my Swift Library</a> 
that can read and write QIF files</p>
</dd>
</dl>

==Notes==

This project was created with the aim of bringing QIF support 
to the <a href="https://github.com/bryceac/rcheckbook">CLI version</a>
of <a href="https://github.com/bryceac/BCheckbook">BCheckbook</a>.

It is currently a <abbr title="work in progress">WIP</abbr>, 
but it should be ready for usage.

===Limits===

Like the original library I wrote in Swift, 
this was designed with only noninvestment 
and noninvoice data in mind.

While implementing them may seem trivial, 
there are potential conflicts as the QIF prefixes,
as found on 
<a href="https://en.wikipedia.org/wiki/Quicken_Interchange_Format">Wikipedia</a>.

Also, the check number field is assumed to always be numerical.

Even though, there <strong>can</strong> 
be other values present in QIF values. 
This decision was made to keep things simplistic, 
since the Rust project I plan to use this with 
only allows numerical input.

===Questions===

<ol>
<li>
<dl>
<dt style="font-weight:bold">Why create this when there is already a parsing crate for rust?</dt>
<dd>
<p>When I went looking for ways of reading QIF files, 
I did encounter <a href="https://crates.io/crates/qif_parser">qif_parser</a>, 
which many people seem to like.</p>
<p>However, 
I could not really use it if I wanted to generate a QIF file, 
which is what I wanted to do.</p>

<p>Also, 
while I could have utilized it for the import functionality,
trying to figure out how it worked 
and would mean I'd just be reimplementing things anyway.</p>

<p>As such, it felt more worth it to just make it myself.</p>
</dd>
</dl>
</li>
<li>
<dl>
<dt style="font-weight:bold">Does this work the same as your original library, since this is a Rust port?</dt>
<dd>
<p>While the design is the same, 
due to a focused need for only single entry components, 
there are some differences. For example, 
while my Swift library uses dictionaries, which Rust calls HashMaps, 
to store different types of QIF details, 
this port has those same sections as their own fields. 
This was done because making custom types hashable 
is not as easy to do in Rust.</p>
<p>However, things should be just as simple.</p>
</dd>
</dl>
</li>
<li>
<dl>
<dt style="font-weight:bold">Are the QIF files produced here compatible with your iOS and macOS apps that use the original library?</dt>
<dd>
<p>They <strong>should</strong> be compatible with the iOS apps 
when I get around to getting the library updated in the project.</p>
<p>However, I am having troubles with the macOS app at this time, 
as there are updates that need to be pushed, but 
due to issues with third party libraries 
that would end up making the app unusable, I cannot push those updates out.</p>
<p>Until the issues on the macOS side can be resolved, 
I suggest not using the QIF files generated by 
this library with the macOS GUI application.</p>
</dd>
</dl>
</li>
</ol>

===Usage===

While this library cannot yet be used by Carho directly, 
in the simple manner most crates can be used, 
you should be able to import it via Cargo like this:

<pre>
qif = { git = "https://github.com/bryceac/qif_rs" }
</pre>

or

<pre>
qif = { git = "https://github.com/bryceac/qif_rs", branch = "main" }
</pre>

====Reading====

To read a file, you would do something like this:

<pre>
use qif::QIF;

fn main() {
let format = Date::DateFormat::MonthDayFullYear;

let qif = QIF::load_from_file("path/to/qif", &format);

if let Some(bank) = qif.bank {
    println!("{}", bank)
}
}
</pre>

This will attempt to read a file and 
display details regarding bank transactions.

====Writing to File====

To write QIF data to a file, you would do something like this:

<pre>
use qif::{ QIF, Section, Transaction };

fn main() {
...
let format = Date::DateFormat::MonthDayFullYear;
let bank_section = Section::builder()
        .set_type("Bank")
        .add_transaction(sam_hill)
        .add_transaction(fake_street)
        .add_transaction(velociraptor_entertainment)
        .build().unwrap();

let qif = QIF::builder()
        .set_field(bank_section)
        .build();

qif.save("path/to/qif", &format).unwrap();
}
</pre>

This will take the bank transactions and save them to a QIF file.

====Creating a Transaction====

Transactions can be created like this:

<pre>
use qif::Transaction;

fn main() {
let today = Local::now();

let format = DateFormat::MonthDayFullYear;

let transaction = Transaction::builder()
    .set_date(&today.format(format.chrono_str()).to_string(), &format)
    .set_check_number(1260)
    .set_vendor("Sam Hill Credit Union")
    .set_address("Sam Hill Credit Union")
    .set_category("Opening Balance")
    .set_amount(500.0)
    .set_memo("Open Account")
    .set_status("*")
    .build();
}
</pre>

The date format above is optional, 
but it provides a convenience factor in that it houses some default
schemes for chrono formats. The example provided above 
uses the MM/DD/YYYY format, and the status denotes it as reconciled.

====Creating a Split====

Splits can be created like this:

<pre>
use qif::Split;

fn main() {
let split = Split::builder()
    .set_category("Opening Balance")
    .set_memo("Bonus for new Account")
    .set_amount(50.0)
    .build();
}
</pre>

By substiting out <strong>set_amount</strong> for 
<strong>set_amount_via_percentage</strong>, 
you can have the calculations done for you, 
but you must also pass the original transaction's amount to the function.

Splits are then added to transactions like this:

<pre>
use qif::{Split, Transaction };

fn main() {
    let transaction = Transaction::builder()
    .set_date(&today.format(format.chrono_str()).to_string(), &format)
    .set_check_number(1260)
    .set_vendor("Sam Hill Credit Union")
    .set_address("Sam Hill Credit Union")
    .set_category("Opening Balance")
    .set_amount(500.0)
    .set_memo("Open Account")
    .set_status("*")
    .add_split(split)
    .build();
}
</pre>